<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: Inter, system-ui, sans-serif;
      margin: 0;
      padding: 16px;
      background: #1e1e1e;
      color: #e0e0e0;
      font-size: 13px;
    }
    .status {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
    }
    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #f44;
    }
    .dot.connected { background: #4caf50; }
    .log {
      background: #111;
      border-radius: 6px;
      padding: 8px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 11px;
      line-height: 1.5;
    }
    .log-entry { opacity: 0.7; }
    .log-entry.error { color: #f44; opacity: 1; }
    .log-entry.success { color: #4caf50; opacity: 1; }
  </style>
</head>
<body>
  <div class="status">
    <div class="dot" id="dot"></div>
    <span id="statusText">Disconnected</span>
  </div>
  <div class="log" id="log"></div>

  <script>
    const WS_URL = 'ws://localhost:9418';
    const dot = document.getElementById('dot');
    const statusText = document.getElementById('statusText');
    const logEl = document.getElementById('log');
    let ws = null;
    let reconnectTimer = null;

    function log(msg, type = '') {
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function setConnected(connected) {
      dot.className = 'dot' + (connected ? ' connected' : '');
      statusText.textContent = connected ? 'Connected to Elio' : 'Disconnected';
    }

    function connect() {
      if (ws && ws.readyState === WebSocket.OPEN) return;

      try {
        ws = new WebSocket(WS_URL);

        ws.onopen = () => {
          setConnected(true);
          log('Connected to Elio MCP server', 'success');
          if (reconnectTimer) {
            clearInterval(reconnectTimer);
            reconnectTimer = null;
          }
        };

        ws.onmessage = (event) => {
          try {
            const command = JSON.parse(event.data);
            log(`Command: ${command.type} (${command.id.slice(0, 8)})`);
            parent.postMessage({ pluginMessage: { type: 'command', command } }, '*');
          } catch (err) {
            log('Failed to parse command: ' + err.message, 'error');
          }
        };

        ws.onclose = () => {
          setConnected(false);
          log('Disconnected');
          if (!reconnectTimer) {
            reconnectTimer = setInterval(connect, 5000);
          }
        };

        ws.onerror = () => {
          log('Connection error', 'error');
        };
      } catch (err) {
        log('Failed to connect: ' + err.message, 'error');
      }
    }

    // Receive responses from main thread
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (msg && msg.type === 'response' && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(msg.response));
        log(`Response sent: ${msg.response.status}`, msg.response.status === 'ok' ? 'success' : 'error');
      }
    };

    connect();
  </script>
</body>
</html>
